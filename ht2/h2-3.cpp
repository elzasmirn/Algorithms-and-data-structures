/*Разрезание блинов
На очень большом столе разложено много абсолютно круглых блинов, некоторые из которых могут частично или полностью налегать друг на друга. 
Абсолютно прямым ножом проводится луч из первой точки по направлению ко второй. 
Требуется определить, какие из блинов будут задеты разрезом. Касания НЕ учитываются.
Input format
В первой строке — координаты двух точек на плоскости, которые определяют луч разреза.
Во второй строке — количество блинов 1⩽N⩽100000.
В следующих N строках по три числа — координаты центра блина и его радиус.
Все координаты — целые числа от -10000 до 10000.
Радиус — строго положительное целое число.
Output format
Номера разрезанных блинов в порядке возрастания. Нумерация блинов начинается с 1.*/

#include <iostream>
#include <stdlib.h>
#include <math.h> 

int main()
{
    int x1, y1, x2, y2, N, A, B, C;
    std::cin >> x1 >> y1 >> x2 >> y2;
    A = y1 - y2;
    B = x2 - x1;
    int sum_of_squares = A * A + B * B;
    std::cin >> N;
    int x0, y0, r, x_1, x_2, y_1, y_2;
    double dist, x, y, scalar_prod, dist_c;
    for (int i = 1; i <= N; ++i)
    {
        std::cin >> x0 >> y0 >> r;
        // центр окружности - начало координат
        x_1 = x1 - x0;
        y_1 = y1 - y0;
        x_2 = x2 - x0;
        y_2 = y2 - y0;
        C = x_1 * y_2 - x_2 * y_1;
        // расстояние от центра окружности до ее проекции на прямую
        dist = abs(C) / sqrt(sum_of_squares);
        // координаты проекции центра окружности на прямую
        x = - A * C / sum_of_squares;
        y = - B * C / sum_of_squares;
        // если скалярное произведение > 0, то проекция лежит на луче
        scalar_prod = (x_2 - x_1) * (x - x_1) + (y_2 - y_1) * (y - y_1);
        // если проекция не лежит на луче, но начало луча внутри окружности
        dist_c = sqrt(x_1 * x_1 + y_1 * y_1);
        if ((dist < r) && (scalar_prod >= 0 || dist_c < r)) std::cout << i << ' ';
    }
    return 0;
}