/*Сортировка матрицы
Если можно сравнивать строки, почему бы нельзя было сравнивать и матрицы, то есть двумерные массивы? 
Для простоты положим, что операция сравнения определена только для матриц с одинаковым количеством строк и столбцов.
Пронумеруем элементы матрицы слева направо и сверху вниз, например, матрица 3*4 будет пронумерована так: 
1 2 3 4
5 6 7 8
9 10 11 12
Сравнение матриц заключается в следующем: сравниваются первые элементы. Если один из них больше, то больше и соответствующая матрица. 
Если они равны, то берётся второй элемент и т. д. Такое сравнение называется лексикографическим.
Вам дана матрица из N строк и M столбцов, 3⩽N,M⩽500, состоящая из различных целых чисел от 1 до 231-1.
Разрешается переставлять произвольное количество раз любые две строки или любые два столбца. 
Ваша задача получить такими перестановками лексикографически наименьшую матрицу и вывести её.
Input format
N M
A11 A12 ... A1M
A21 A22 ... A2M
... 
AN1 AN2 ... ANM
Output format
Лексикографически наименьшая матрица из всех возможных после произвольного количества перестановок строк и столбцов.*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    unsigned n, m, elem;
    cin >> n >> m;
    vector< vector<unsigned> > matrix(n);
    size_t i_min = 0, j_min = 0; // индексы минимального элемента
    unsigned min = 2147483648; // 2^31
    for(size_t i = 0; i < n; ++i)
    {
        matrix[i].resize(m);
        for(size_t j = 0; j < m; ++j)
        {
            cin >> elem;
            matrix[i][j] = elem;
            if (elem < min) 
            {
                min = elem;
                i_min = i;
                j_min = j;
            }
        }
    }
    vector < pair<unsigned, size_t> > first_line(m, {0, 0}); // строка с минимальным элементом и исходными индексами столбцов
    for(size_t j = 0; j < m; ++j)
    {
        first_line[j] = {matrix[i_min][j], j};
    }
    sort(first_line.begin(), first_line.end()); // second - исходные номера стобцов
    vector < pair<unsigned, size_t> > first_column(n, {0, 0}); // столбец с минимальным элементом и исходными индексами строк
    for(size_t i = 0; i < n; ++i)
    {
        first_column[i] = {matrix[i][j_min], i};
    }
    sort(first_column.begin(), first_column.end()); // second - исходные номера строк
    for(size_t i = 0; i < n; ++i)
    {
        for(size_t j = 0; j < m; ++j)
        {
            cout << matrix[first_column[i].second][first_line[j].second] << ' ';
        }
        cout << endl;
    }
    return 0;
}