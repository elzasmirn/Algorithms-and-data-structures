/*Обратное число по модулю
Известно, что команда деления целых чисел на современных компьютерах исполняется неприлично долго. 
Оптимизирующие компиляторы во многих случаях заменяют операцию деления на константу группой операций, в которых имеется умножение на другую константу.
Для этого компилятору, в числе других действий, требуется найти такое неотрицательное число q для заданного делителя p, что q * p = 1 по известному модулю m.
Ваша задача по заданным числам 2 ⩽ p,m ⩽ 4 294 967 295 найти любое неотрицательное число q такое, чтобы (p * q) (mod m) = 1.
Известно также, что m — простое число, и что для заданных p и m ответ существует.
Input format
p m
Output format
q*/

#include <iostream>

long long gcd (long long a, long long b, long long & x, long long & y) {
	if (a == 0) {
		x = 0; y = 1;
		return b;
	}
	long long x1, y1;
	long long d = gcd (b % a, a, x1, y1);
	x = y1 - (b / a) * x1;
	y = x1;
	return d;
}

int main()
{
    long long p, m;
    std::cin >> p >> m;
    long long x, y;
    long long g = gcd (p, m, x, y);
    if (g != 1)
	    std::cout << "no solution" << std::endl;
    else {
	    x = (x % m + m) % m;
	    std::cout << x << std::endl;
    }
}