/*Перестановки
Как известно, из множества из N различных предметов можно сделать N! различных перестановок.
Если предметы можно сравнивать между собой, то перестановки можно перенумеровать в лексикографическом порядке. 
Например, перестановки множества {1,2,3} будут идти в следующем порядке: {1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,1,2}, {3,2,1}.
Таким образом, все перестановки множества различных элементов можно пронумеровать от 1 до N!.
В нашей задаче мы будем переставлять элементы из множества натуральных чисел от 1 до N.
Input format
На вход программы подаётся два числа — количество предметов в перестановке 2⩽N⩽20 и номер перестановки 1⩽M⩽2×1018.
Output format
Вывести через пробел элементы перестановки, имеющей номер M.*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int N;
    long long M;
    cin >> N >> M;
    long long fact[21] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 
        1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000}; 
    vector<bool> used(N + 1,false);
    for (int i = 0; i < N; i++) {
        long long block_num = (M - 1) / fact[N - i - 1] + 1;
        int j, pos = 0;
        for (j = 1; j < used.size(); j++) {
            if (!used[j]) pos++;
            if (block_num == pos)
            break;
        }
        cout << j << ' ';
        used[j] = true;
        M = (M - 1) % fact[N - i - 1] + 1;
    }
    return 0;
}